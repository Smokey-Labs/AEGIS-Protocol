name: AEGIS GitHub -> Discord

on:
  issues:
    types: [opened, edited, closed, reopened]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, edited, closed, reopened, ready_for_review, converted_to_draft, synchronize]
  release:
    types: [published, edited]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Post GitHub event to Discord
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          set -euo pipefail

          # Sanitize webhook (strip CR/LF)
          WEBHOOK="$(printf "%s" "${DISCORD_WEBHOOK:-}" | tr -d '\r\n')"

          if [ -z "$WEBHOOK" ]; then
            echo "Missing DISCORD_WEBHOOK secret"
            exit 1
          fi

          # Non-secret diagnostics (do NOT print the webhook)
          case "$WEBHOOK" in
            https://discord.com/api/webhooks/*|https://ptb.discord.com/api/webhooks/*|https://canary.discord.com/api/webhooks/*)
              echo "Webhook URL format: looks like Discord API webhook ✅"
              ;;
            *)
              echo "Webhook URL format: DOES NOT look like https://discord.com/api/webhooks/... ❌"
              echo "Fix: Discord -> Channel Settings -> Integrations -> Webhooks -> Copy Webhook URL, then update the secret."
              exit 1
              ;;
          esac

          # Build message text (simple + readable + no jq)
          python3 - <<'PY' > payload.json
          import json, os

          event = os.environ.get("GITHUB_EVENT_NAME", "")
          action = (os.environ.get("GITHUB_EVENT_ACTION", "") or "").strip()
          repo = os.environ.get("GITHUB_REPOSITORY", "")
          actor = os.environ.get("GITHUB_ACTOR", "")

          server_url = os.environ.get("GITHUB_SERVER_URL", "https://github.com").rstrip("/")
          run_id = (os.environ.get("GITHUB_RUN_ID", "") or "").strip()
          run_url = f"{server_url}/{repo}/actions/runs/{run_id}" if repo and run_id else ""

          # Read the event payload
          with open(os.environ["GITHUB_EVENT_PATH"], "r", encoding="utf-8") as f:
            data = json.load(f)

          def clamp(s, n=700):
            s = (s or "").replace("\r","").strip()
            return s if len(s) <= n else s[:n] + "…"

          def strip_leading_blank_lines(s):
            if not s:
              return ""
            lines = s.replace("\r", "").split("\n")
            while lines and lines[0].strip() == "":
              lines.pop(0)
            return "\n".join(lines).strip()

          title = ""
          url = ""
          details = ""

          if event == "issues":
            issue = data.get("issue", {})
            title = issue.get("title","")
            url = issue.get("html_url","")
            details = clamp(issue.get("body",""))

          elif event == "issue_comment":
            issue = data.get("issue", {})
            c = data.get("comment", {})
            title = issue.get("title","")
            url = c.get("html_url") or issue.get("html_url","")
            details = clamp(c.get("body",""))

          elif event == "pull_request":
            pr = data.get("pull_request", {})
            title = pr.get("title","")
            url = pr.get("html_url","")
            details = clamp(pr.get("body",""))

          elif event == "release":
            rel = data.get("release", {})
            title = rel.get("name") or rel.get("tag_name","")
            url = rel.get("html_url","")
            details = clamp(rel.get("body",""))

          elif event == "workflow_dispatch":
            # workflow_dispatch has no "action" in the payload; treat as manual
            if not action:
              action = "manual"

            # Prefer a link to the specific run; fallback to repo URL.
            url = run_url or data.get("repository", {}).get("html_url","")

            # Show branch/ref + inputs (if any)
            ref = data.get("ref", "") or os.environ.get("GITHUB_REF", "")
            ref_name = (os.environ.get("GITHUB_REF_NAME", "") or "").strip()

            inputs = data.get("inputs") or {}
            if isinstance(inputs, dict) and inputs:
              inputs_lines = [f"{k}: {v}" for k, v in inputs.items()]
              inputs_text = "Inputs:\n" + "\n".join(inputs_lines)
            else:
              inputs_text = "Inputs: (none)"

            # Title for workflow_dispatch
            title = "Manual Run"
            # Details block
            ref_display = ref_name or ref or "(unknown)"
            details = clamp(f"Ref: {ref_display}\n{inputs_text}")

          else:
            # Generic fallback
            if not action:
              action = "event"
            title = "(event)"
            url = run_url or data.get("repository", {}).get("html_url","") or (f"{server_url}/{repo}" if repo else "")
            details = ""

          # Remove leading blank lines so Discord doesn't "eat" the first line in code blocks
          details = strip_leading_blank_lines(details)

          header = f"**AEGIS GitHub** • `{event}` → `{action}`"
          line2 = f"**Repo:** `{repo}`" if repo else ""
          line3 = f"**By:** `{actor}`" if actor else ""
          line4 = f"**Title:** {title}" if title else ""
          line5 = f"**Link:** {url}" if url else ""
          # Code block with explicit newlines for stable rendering
          line6 = f"**Details:**\n```\n{details}\n```" if details else ""

          msg = "\n".join([x for x in [header, line2, line3, line4, line5, line6] if x])

          print(json.dumps({"content": msg}, ensure_ascii=False))
          PY

          # Post with a normal User-Agent and show response body on failure
          curl --silent --show-error --fail-with-body \
            -H "Content-Type: application/json" \
            -H "User-Agent: GitHubActions-DiscordWebhook/1.0" \
            -X POST \
            --data @payload.json \
            "$WEBHOOK?wait=true"
