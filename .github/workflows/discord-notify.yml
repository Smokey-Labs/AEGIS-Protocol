name: AEGIS GitHub ‚Üí Discord

on:
  issues:
    types: [opened, edited, closed, reopened]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, edited, closed, reopened, ready_for_review, converted_to_draft, synchronize]
  release:
    types: [published, edited]
  workflow_dispatch:

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Post GitHub event to Discord
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          set -euo pipefail

          python3 -c "
import json, os, sys, urllib.request, urllib.error

webhook = (os.environ.get('DISCORD_WEBHOOK') or '').strip()
if not webhook:
    print('Missing DISCORD_WEBHOOK secret', file=sys.stderr)
    sys.exit(1)

event_path = os.environ.get('GITHUB_EVENT_PATH')
event_name = os.environ.get('GITHUB_EVENT_NAME', '')
repo = os.environ.get('GITHUB_REPOSITORY', '')
actor = os.environ.get('GITHUB_ACTOR', '')

with open(event_path, 'r', encoding='utf-8') as f:
    payload = json.load(f)

action = payload.get('action', '')

def clamp(s, n=1200):
    s = (s or '').replace('\\r', '').strip()
    if len(s) > n:
        return s[:n] + '‚Ä¶'
    return s

def codeblock(s):
    s = clamp(s)
    if not s:
        return ''
    # avoid breaking Markdown with triple backticks
    s = s.replace('```', '``\\u200b`')
    return f'```{s}```'

def pick(*paths):
    # paths: list of (obj, key, key, ...)
    for p in paths:
        cur = payload
        ok = True
        for k in p:
            if isinstance(cur, dict) and k in cur:
                cur = cur[k]
            else:
                ok = False
                break
        if ok and cur:
            return cur
    return None

# Common URLs / titles
url = (
    pick(('comment','html_url'), ('issue','html_url'), ('pull_request','html_url'), ('release','html_url'))
    or pick(('repository','html_url'))
    or ''
)

title = (
    pick(('issue','title'), ('pull_request','title'), ('release','name'))
    or pick(('release','tag_name'))
    or '(no title)'
)

number = (
    pick(('issue','number'), ('pull_request','number'))
)

# Bodies: comment body OR issue/pr body OR release notes
detail = (
    pick(('comment','body'),)
    or pick(('issue','body'),)
    or pick(('pull_request','body'),)
    or pick(('release','body'),)
    or ''
)

# Build a clean, readable message
header = 'üõ°Ô∏è **AEGIS Protocol ‚Äî GitHub Update**'
line_event = f'**Event:** `{event_name}`' + (f' ‚Ä¢ **Action:** `{action}`' if action else '')
line_repo = f'**Repo:** `{repo}`'
line_actor = f'**By:** `{actor}`'
line_item = ''
if number is not None:
    line_item = f'**Item:** #{number} ‚Äî {title}'
else:
    line_item = f'**Title:** {title}'

lines = [header, '', line_event, line_repo, line_item, line_actor]
if url:
    lines.append(f'**Link:** {url}')

if detail.strip():
    lines.append('')
    lines.append('**Details:**')
    lines.append(codeblock(detail))

content = '\\n'.join(lines)

body = json.dumps({'content': content}).encode('utf-8')
req = urllib.request.Request(
    webhook,
    data=body,
    headers={'Content-Type': 'application/json'},
    method='POST'
)

try:
    with urllib.request.urlopen(req, timeout=20) as resp:
        print('Discord response:', resp.status)
except urllib.error.HTTPError as e:
    err = e.read().decode('utf-8', errors='replace')
    print('Discord HTTPError:', e.code, err, file=sys.stderr)
    sys.exit(1)
"
