name: AEGIS GitHub â†’ Discord

on:
  issues:
    types: [opened, edited, closed, reopened]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, edited, closed, reopened, ready_for_review, converted_to_draft, synchronize]
  release:
    types: [published, edited]
  workflow_dispatch:

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Post GitHub event to Discord
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import json, os, sys, urllib.request, urllib.error

          webhook = (os.environ.get("DISCORD_WEBHOOK") or "").strip()
          if not webhook:
              print("Missing DISCORD_WEBHOOK secret", file=sys.stderr)
              sys.exit(1)

          event_path = os.environ.get("GITHUB_EVENT_PATH")
          event_name = os.environ.get("GITHUB_EVENT_NAME", "")
          repo = os.environ.get("GITHUB_REPOSITORY", "")
          actor = os.environ.get("GITHUB_ACTOR", "")

          with open(event_path, "r", encoding="utf-8") as f:
              payload = json.load(f)

          action = payload.get("action", "")

          def clamp(s: str, n: int = 1400) -> str:
              s = (s or "").replace("\r", "").strip()
              return (s[:n] + "â€¦") if len(s) > n else s

          def codeblock(s: str) -> str:
              s = clamp(s)
              if not s:
                  return ""
              s = s.replace("```", "``\u200b`")  # prevent breaking code fences
              return f"```{s}```"

          def deep_get(obj, path):
              cur = obj
              for key in path:
                  if isinstance(cur, dict) and key in cur:
                      cur = cur[key]
                  else:
                      return None
              return cur

          def first(*candidates):
              for obj, path in candidates:
                  val = deep_get(obj, path)
                  if val:
                      return val
              return None

          # URLs and titles
          url = first(
              (payload, ["comment", "html_url"]),
              (payload, ["issue", "html_url"]),
              (payload, ["pull_request", "html_url"]),
              (payload, ["release", "html_url"]),
              (payload, ["repository", "html_url"]),
          ) or ""

          title = first(
              (payload, ["issue", "title"]),
              (payload, ["pull_request", "title"]),
              (payload, ["release", "name"]),
              (payload, ["release", "tag_name"]),
          ) or "(no title)"

          number = first(
              (payload, ["issue", "number"]),
              (payload, ["pull_request", "number"]),
          )

          # Details priority: comment > issue body > PR body > release notes
          detail = first(
              (payload, ["comment", "body"]),
              (payload, ["issue", "body"]),
              (payload, ["pull_request", "body"]),
              (payload, ["release", "body"]),
          ) or ""

          # Build message
          header = "ðŸ›¡ï¸ **AEGIS Protocol â€” GitHub Update**"
          line_event = f"**Event:** `{event_name}`" + (f" â€¢ **Action:** `{action}`" if action else "")
          line_repo = f"**Repo:** `{repo}`"
          line_actor = f"**By:** `{actor}`"

          if number is not None:
              line_item = f"**Item:** #{number} â€” {title}"
          else:
              line_item = f"**Title:** {title}"

          lines = [header, "", line_event, line_repo, line_item, line_actor]
          if url:
              lines.append(f"**Link:** {url}")

          if detail.strip():
              lines.extend(["", "**Details:**", codeblock(detail)])

          content = "\n".join(lines)

          # Discord hard limit is 2000 chars for content; keep margin
          if len(content) > 1900:
              content = content[:1900] + "â€¦"

          body = json.dumps({"content": content}).encode("utf-8")

          req = urllib.request.Request(
              webhook,
              data=body,
              headers={"Content-Type": "application/json"},
              method="POST",
          )

          try:
              with urllib.request.urlopen(req, timeout=20) as resp:
                  print("Discord response:", resp.status)
          except urllib.error.HTTPError as e:
              err = e.read().decode("utf-8", errors="replace")
              print("Discord HTTPError:", e.code, err, file=sys.stderr)
              sys.exit(1)
          PY
